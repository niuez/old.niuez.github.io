{"categories":[{"title":"Algorithms","uri":"https://niuez.github.io/categories/algorithms/"}],"posts":[{"content":"Tarjan\u0026rsquo;s off-line LCAを書いてみたので, その時のメモです.\nネタバレ注意\nNo.898 tri-βutree - yukicoder のちょっとしたネタバレが含まれます\u0026hellip;\nTarjan\u0026rsquo;s off-line LCA(lowest common ancestors)は, LCAをoff-lineで$O((N + Q) \\alpha (N))$で求めるアルゴリズムです. ($\\alpha$は逆アッカーマン関数)\nTarjan\u0026rsquo;s off-line lowest common ancestors algorithm - Wikipedia\nDFSの帰りがけに, Union Findで木の辺をuniteしていく. すると, Union Findで表現している集合は, いまたどっている頂点とのLCAが同じになる頂点の集合になります.\n具体例はこんな感じ. いま頂点$6$を見ているとします. 二重線はまだつなげていない辺です.\n緑の集合は, 頂点$6$とのLCAが頂点$0$である集合です. また, 青の集合は, 頂点$6$とのLCAが頂点$4$である集合です.\nDFSの戻りってこういうことできるんだなあ\n実装 注意点はクエリを処理するタイミングで, LCAを求めたい頂点２つのどちらもがdfsされた時であること(なのでans == -2を挟んでいる)\n#include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; struct union_find { vector\u0026lt;int\u0026gt; par; vector\u0026lt;int\u0026gt; rank; union_find(int n) : par(n) , rank(n) { for(int i = 0;i \u0026lt; n;i++) par[i] = i; } int root(int i) { return par[i] == i ? i : par[i] = root(par[i]); } /* unite x, y return parent */ int unite(int x,int y) { x = root(x); y = root(y); if(x == y) return -1; if(rank[x] \u0026lt; rank[y]) { par[x] = y; return y; } else { par[y] = x; if(rank[x] == rank[y]) rank[x]++; return x; } } }; using i64 = long long; struct tarjans_offline_lca { using E = pair\u0026lt;int, i64\u0026gt;; vector\u0026lt;vector\u0026lt;E\u0026gt;\u0026gt; G; vector\u0026lt;int\u0026gt; ance; union_find uf; vector\u0026lt;i64\u0026gt; weight; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; query; vector\u0026lt;vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt; q; vector\u0026lt;int\u0026gt; ans; tarjans_offline_lca(int n): G(n), ance(n), uf(n), weight(n), q(n) {} void add_edge(int a, int b, i64 w) { G[a].push_back({ b, w }); G[b].push_back({ a, w }); } void add_query(int a, int b) { int i = query.size(); query.push_back({ a, b }); q[a].push_back({ b, i }); q[b].push_back({ a, i }); } void dfs(int v, int f, i64 W) { ance[v] = v; weight[v] = W; for(auto e: G[v]) { int u = e.first; i64 w = e.second; if(f == u) continue; dfs(u, v, w + W); uf.unite(u, v); ance[uf.root(v)] = v; } for(auto e: q[v]) { int u = e.first; int i = e.second; if(ans[i] == -1) ans[i] = -2; else if(ans[i] == -2) ans[i] = ance[uf.root(u)]; } } void offline_lca(int root) { ans.assign(query.size(), -1); dfs(root, -1, 0); } };  使用例です. $N = 10^5$, LCAのクエリ数$Q = 3 * 10^5$で196msならいいんじゃない？ #426438 No.898 tri-βutree - yukicoder\nHLDが速いんじゃ HLDなんでこんなに速いんですかね. $O(N + Q \\log N)$のはずなんですが\u0026hellip; 100ms #426441 No.898 tri-βutree - yukicoder\nしめ クエリを二回見てるのがダメなんですかね\u0026hellip; LCAやるときはHLDでいいでしょう\u0026hellip;\nでも, DFS帰りがけがかなり面白い. どこかで使えるといいな\n","id":0,"section":"posts","summary":"Tarjan\u0026rsquo;s off-line LCAを書いてみたので, その時のメモです. ネタバレ注意 No.898 tri-βutree - yukicoder のちょっとしたネタバレが含まれます\u0026hellip; Tarjan\u0026rsquo;s off-line LCA(lowest","tags":["DFS","LCA","Tree"],"title":"Tarjan's off-line LCA の実装メモと速度","uri":"https://niuez.github.io/2020/02/tarjans_offline_lca/","year":"2020"},{"content":"移植テストです\n書いて置かないと頭に置いておけない気がしたのでメモを残す. 間違ってたらごめん\nこれについて気になったので\nメビウス関数とかを導入するとより形式的に約数とかを扱えるようになるのかなあ\n\u0026mdash; Niuez (@xiuez) January 22, 2020  概要  約数畳み込み メビウス関数 メビウスの反転公式(約数畳み込みの逆操作) 約数畳み込みと逆約数畳み込みのアルゴリズム $O(A \\log{\\log A})$ 最大公約数の扱い 集合の扱い AGC038C LCMsの解き方  ネタバレあるので気をつけてください\n約数畳み込み 関数$f(n)$に対する約数畳み込みとは,\n$\\begin{eqnarray} g(n) = \\sum_{ d | n } f(d) \\end{eqnarray}$\nあとで解説しますが, 方針としてはこの畳み込んだ後の$g(n)$を問題を解けるように定義してやることでGCDを綺麗に扱うことができます.\nメビウス関数 実際に$g(n)$を定義してみます. 一番有名なのは$g(n) = \\delta(n, 1)$です. $\\delta(n, 1)$はクロネッカーのデルタです. このとき,\n$\\begin{eqnarray} g(n) = \\delta(n, 1) = \\sum_{ d | n } f(d) \\end{eqnarray}$\nを満たす$f(n)$はメビウス関数と呼ばれ, $\\mu(n)$と書きます.(メビウス関数 - Wikipedia)\nメビウスの反転公式(約数畳み込みの逆操作) 上の式のままだと, $f(n)$を導くのは困難です. ここで登場するのがメビウスの反転公式です. これは, 約数畳み込みの逆操作に当たります.\n$$ \\begin{eqnarray} g(n) \u0026amp;=\u0026amp; \\sum_{ d | n } f(d) \\\\\nf(n) \u0026amp;=\u0026amp; \\sum_{ d | n } g(d) \\mu(\\frac{n}{d}) \\end{eqnarray} $$\nこれで$g(n)$を定義してから反転公式を適用することで$f(n)$を導くことができます.\n約数畳み込みと逆約数畳み込みのアルゴリズム 約数畳み込みとその逆はnoshi91さんが計算量$O(A \\log{\\log A})$で計算するアルゴリズムの記事を紹介しています.\nhttp://noshi91.hatenablog.com/entry/2018/12/27/121649\n逆約数畳み込みの実装例\ntemplate \u0026lt;class T\u0026gt; void inverse_divisor_transform(vector\u0026lt;T\u0026gt; \u0026amp;a) { int n = a.size(); vector\u0026lt;bool\u0026gt; sieve(n, true); for (int p = 2; p \u0026lt; n; ++p) { if (sieve[p]) { for (int k = (n - 1) / p; k \u0026gt; 0; --k) { sieve[k * p] = false; a[k * p] -= a[k]; } } } }  最大公約数の扱い 自然数$n, m$に対して,\n$\\begin{eqnarray} \\sum_{d | n, d | m} f(d) \\end{eqnarray}$\nを考えると,\n$$ \\begin{eqnarray} \\sum_{d | n, d | m} f(d) \u0026amp;=\u0026amp; \\sum_{d | \\gcd(n, m)} f(d) \\\\\n\u0026amp;=\u0026amp; g(\\gcd(n, m)) \\end{eqnarray} $$\nとなり, $\\gcd(n, m)$に対する操作ができます. 例えば, $f(n) = \\mu(n), g(n) = \\delta(n, 1)$とすると, $g(\\gcd(n, m))$は,「$n, m$が互いに素であれば$1$, そうでなければ$0$」となり, 互いに素かどうかの判定ができます.\n集合の扱い 例えば, $c_m(d) = [d | m$]という関数($d$が$m$を割り切るなら$1$, そうでなければ$0$)を考えると,\n$$ \\sum_{d | n, d | m} f(d) = \\sum_{ d | n } f(d) c_m(d) $$\nと変形できます.\nこれを応用します. 自然数の集合$S$ を考え, $c(d) = \\sum_{m \\in S} c_m(d)$とすると,\n$$ \\begin{eqnarray} \\sum_{d | n} f(d) c(d) \u0026amp;=\u0026amp; \\sum_{m \\in S}\\sum_{d | n} f(d) c_m(d) \\\\\n\u0026amp;=\u0026amp; \\sum_{m \\in S} g(\\gcd(n, m)) \\end{eqnarray} $$\nとなります.\n$f(n) = \\mu(n), g(n) = \\delta(n, 1)$を考えてみると, 「集合$S$の中に$n$と互いに素な要素の数」を計算しています.\nAGC038C LCMsを解く AGC038 C - LCMs $lcm(x, y) = x (\\frac{y}{\\gcd(x, y)})$と変形します. 約数畳み込みを使う方針でやると, この$(\\frac{y}{\\gcd(x, y)})$が最後に来てほしい気持ちになります. $g(n) = \\frac{1}{n}$と置くと,\n$$ \\begin{eqnarray} \\frac{y}{\\gcd(x, y)} \u0026amp;=\u0026amp; y \\cdot g(\\gcd(x, y)) \\\\\n\u0026amp;=\u0026amp; \\sum_{d | gcd(x, y)} f(d) y \\\\\n\u0026amp;=\u0026amp; \\sum_{d | x, d | y} f(d) y \\\\\n\u0026amp;=\u0026amp; \\sum_{d | x} f(d) s_y(d) \\end{eqnarray} $$\nここで$s_y(d)$を「$d$が$y$を割り切るなら$y$, そうでなければ$0$」としました.\n応用して, 自然数の集合$S$ を考え, $s(d) = \\sum_{m \\in S} s_m(d)$とすると,\n$$ \\begin{eqnarray} \\sum_{d | x} f(d) s(d) \u0026amp;=\u0026amp; \\sum_{y \\in S}\\sum_{d | x} f(d) s_y(d) \\\\\n\u0026amp;=\u0026amp; \\sum_{y \\in S} y \\cdot g(\\gcd(x, y)) \\end{eqnarray} $$\nと計算できて, これに$x$を掛けると「集合$S$の中の各要素と$x$の最大公約数の和」を計算できました.\n計算量は, $O(A \\log{\\log A} + N \\sqrt A)$です.\nC - LCMs の僕の提出\nソースコード\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using i64 = long long; #define rep(i,s,e) for(i64 (i) = (s);(i) \u0026lt; (e);(i)++) /* modint */ /* IO(niu::fin, niu::fout) */ const i64 MOD = 998244353; using fp = modint\u0026lt;MOD\u0026gt;; #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using i64 = long long; template \u0026lt;class T\u0026gt; void inverse_divisor_transform(vector\u0026lt;T\u0026gt; \u0026amp;a) { int n = a.size(); vector\u0026lt;bool\u0026gt; sieve(n, true); for (int p = 2; p \u0026lt; n; ++p) { if (sieve[p]) { for (int k = (n - 1) / p; k \u0026gt; 0; --k) { sieve[k * p] = false; a[k * p] -= a[k]; } } } } constexpr i64 A = 1e6 + 1; int main() { std::vector\u0026lt;fp\u0026gt; f(A); rep(d,1,A) { f[d] = fp(d).pow(MOD - 2); } inverse_divisor_transform(f); i64 N; niu::fin \u0026gt;\u0026gt; N; vector\u0026lt;fp\u0026gt; sum(A); fp ans = 0; rep(i,0,N) { int x; niu::fin \u0026gt;\u0026gt; x; fp res = 0; for(int d = 1; d * d \u0026lt;= x; d++) { if(x % d == 0) { res += f[d] * sum[d]; sum[d] += fp(x); if(x / d != d) { res += f[x / d] * sum[x / d]; sum[x / d] += fp(x); } } } ans += res * fp(x); } niu::fout \u0026lt;\u0026lt; ans.value() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; }  ","id":1,"section":"posts","summary":"移植テストです 書いて置かないと頭に置いておけない気がしたのでメモを残す. 間違ってたらごめん これについて気になったので メビウス関数とかを導入す","tags":["Divisor","Transform","Mobius","GCD","LCM"],"title":"約数畳み込みを使って最大公約数と集合をうまく扱うメモ","uri":"https://niuez.github.io/2020/02/divisor_transform_memo/","year":"2020"},{"content":"はじめまして\nいつはてなブログが消えてもおかしくない気がするので, 僕のはてなブログからこっちに移してこようかなと考えてます.\nテスト期間真っ最中なので春休みに入ったらやろうかな.\nにう\n","id":2,"section":"posts","summary":"はじめまして いつはてなブログが消えてもおかしくない気がするので, 僕のはてなブログからこっちに移してこようかなと考えてます. テスト期間真っ最中","tags":null,"title":"First","uri":"https://niuez.github.io/2020/02/first/","year":"2020"}],"tags":[{"title":"DFS","uri":"https://niuez.github.io/tags/dfs/"},{"title":"Divisor","uri":"https://niuez.github.io/tags/divisor/"},{"title":"GCD","uri":"https://niuez.github.io/tags/gcd/"},{"title":"LCA","uri":"https://niuez.github.io/tags/lca/"},{"title":"LCM","uri":"https://niuez.github.io/tags/lcm/"},{"title":"Mobius","uri":"https://niuez.github.io/tags/mobius/"},{"title":"Transform","uri":"https://niuez.github.io/tags/transform/"},{"title":"Tree","uri":"https://niuez.github.io/tags/tree/"}]}